# bash completion for GNU make                             -*- shell-script -*-

# Extract the valid target names starting with PREFIX from the output of
# `make -npq'
# @param mode    If this is `-d', the directory names already specified in
#                PREFIX are omitted in the output
# @param prefix  Prefix of the target names
_comp_cmd_make__extract_targets()
{
    local mode=$1
    local -x prefix=$2

    # display mode, only output current path component to the next slash
    local -x prefix_replace=$prefix
    [[ $mode == -d && $prefix == */* ]] &&
        prefix_replace=${prefix##*/}

    awk '
      BEGIN {
        prefix = ENVIRON["prefix"];
        prefix_replace = ENVIRON["prefix_replace"];
        is_target_block = 0;
        target = "";
      }
      function starts_with(str, prefix) {
        return substr(str, 1, length(prefix)) == prefix;
      }

      NR == 1, /^# +Make data base/ { next; }     # skip any makefile output
      /^# +Finished Make data base/,/^# +Make data base/ { next; } # skip any makefile output
      /^# +Variables/, /^# +Files/ { next; }      # skip until files section
      /^# +Not a target/, /^$/     { next; }      # skip not target blocks

      # The stuff above here describes lines that are not
      #  explicit targets or not targets other than special ones
      # The stuff below here decides whether an explicit target
      #  should be output.

      starts_with($0, prefix) { is_target_block = 1; }
      !is_target_block { next; }

      /^# +File is an intermediate prerequisite/ { # cancel the block
        is_target_block = 0;
        target = "";
        next;
      }

      /^$/ {                                      # end of target block
        is_target_block = 0;
        if (target != "") {
          print target;
          target = "";
        }
        next;
      }

      # only process the targets the user wants.
      /^[^#\t:%]+:/ {                             # found target block
        if (/^\.PHONY:/               ) next;     # special target
        if (/^\.SUFFIXES:/            ) next;     # special target
        if (/^\.DEFAULT:/             ) next;     # special target
        if (/^\.PRECIOUS:/            ) next;     # special target
        if (/^\.INTERMEDIATE:/        ) next;     # special target
        if (/^\.SECONDARY:/           ) next;     # special target
        if (/^\.SECONDEXPANSION:/     ) next;     # special target
        if (/^\.DELETE_ON_ERROR:/     ) next;     # special target
        if (/^\.IGNORE:/              ) next;     # special target
        if (/^\.LOW_RESOLUTION_TIME:/ ) next;     # special target
        if (/^\.SILENT:/              ) next;     # special target
        if (/^\.EXPORT_ALL_VARIABLES:/) next;     # special target
        if (/^\.NOTPARALLEL:/         ) next;     # special target
        if (/^\.ONESHELL:/            ) next;     # special target
        if (/^\.POSIX:/               ) next;     # special target
        if (/^\.NOEXPORT:/            ) next;     # special target
        if (/^\.MAKE:/                ) next;     # special target

        # dont complete with hidden targets unless we are doing a partial completion
        if (prefix == "" || prefix ~ /\/$/)
          if (substr($0, length(prefix) + 1, 1) ~ /[^a-zA-Z0-9]/)
            next;

        target = $0;
        sub(/:.*/, "", target);
        if (prefix_replace != prefix)
          target = prefix_replace substr(target, 1 + length(prefix))

        next;
      }
    '
}

# Truncate the non-unique filepaths in COMPREPLY to only generate unique
# directories or files.  This function discards the files under subdirectories
# unless the path is unique under each subdirectory and instead generate the
# subdirectory path.  For example, when there are two candidates, "abc/def" and
# "abc/xyz", we generate "abc/" instead of generating both candidates directly.
# When there is only one candidate "abc/def", we generate the full path
# "abc/def".
#
# @var[in] cur
# @var[in] mode
# @var[in,out] COMPREPLY
_comp_cmd_make__truncate_non_unique_paths()
{
    local prefix=$cur
    [[ $mode == -d ]] && prefix=
    if ((${#COMPREPLY[@]} > 0)); then
        # collect the possible completions including the directory names in
        # `paths' and count the number of children of each subdirectory in
        # `nchild'.
        local -A paths nchild
        local target
        for target in "${COMPREPLY[@]}"; do
            local path=${target%/}
            while [[ ! ${paths[$path]+set} ]] &&
                paths[$path]=set &&
                [[ $path == "$prefix"*/* ]]; do
                path=${path%/*}
                nchild[$path]=$((${nchild[$path]-0} + 1))
            done
        done

        COMPREPLY=()
        local nreply=0
        for target in "${!paths[@]}"; do
            # generate only the paths that do not have a unique child and whose
            # all parent and ancestor directories have a unique child.
            ((${nchild[$target]-0} == 1)) && continue
            local path=$target
            while [[ $path == "$prefix"*/* ]]; do
                path=${path%/*}
                ((${nchild[$path]-0} == 1)) || continue 2
            done

            # suffix `/' when the target path is a subdiretory, which has
            # at least one child.
            COMPREPLY[nreply++]=$target${nchild[$target]+/}
        done
    fi
}

_comp_cmd_make()
{
    local cur prev words cword was_split comp_args
    _comp_initialize -s -- "$@" || return

    local makef makef_dir=("-C" ".") i

    local noargopts='!(-*|*[foWICmEDVxj]*)'
    # shellcheck disable=SC2254
    case $prev in
        --file | --makefile | --old-file | --assume-old | --what-if | --new-file | \
            --assume-new | -${noargopts}[foW])
            _comp_compgen_filedir
            return
            ;;
        --include-dir | --directory | -${noargopts}[ICm])
            _comp_compgen_filedir -d
            return
            ;;
        -${noargopts}E)
            _comp_compgen -- -v
            return
            ;;
        --eval | -${noargopts}[DVx])
            return
            ;;
        --jobs | -${noargopts}j)
            local ret
            _comp_get_ncpus
            _comp_compgen -- -W "{1..$((ret * 2))}"
            return
            ;;
    esac

    [[ $was_split ]] && return

    if [[ $cur == -* ]]; then
        _comp_compgen_help || _comp_compgen_usage
        [[ ${COMPREPLY-} == *= ]] && compopt -o nospace
    elif [[ $cur == *=* ]]; then
        prev=${cur%%=*}
        cur=${cur#*=}
        local diropt
        [[ ${prev,,} == *dir?(ectory) ]] && diropt=-d
        _comp_compgen_filedir $diropt
    else
        # before we check for makefiles, see if a path was specified
        # with -C/--directory
        for ((i = 1; i < ${#words[@]}; i++)); do
            if [[ ${words[i]} == @(-${noargopts}C|--directory) ]]; then
                # Expand tilde expansion
                local ret
                _comp_dequote "${words[i + 1]-}" &&
                    [[ -d ${ret-} ]] &&
                    makef_dir=(-C "$ret")
                break
            fi
        done

        # before we scan for targets, see if a Makefile name was
        # specified with -f/--file/--makefile
        for ((i = 1; i < ${#words[@]}; i++)); do
            if [[ ${words[i]} == @(-${noargopts}f|--?(make)file) ]]; then
                # Expand tilde expansion
                local ret
                _comp_dequote "${words[i + 1]-}" &&
                    [[ -f ${ret-} ]] &&
                    makef=(-f "$ret")
                break
            fi
        done

        # recognise that possible completions are only going to be displayed so
        # only the base name is shown.
        #
        # Note: This is currently turned off because the test suite of
        # bash-completion conflicts with it; it uses "set show-all-if-ambiguous
        # on" (causing COMP_TYPE == 37) to retrieve the action completion
        # results, and also the compact form with only the basenames is not
        # essentially needed.  To re-enable it, please uncomment the following
        # if-statement.
        local mode=--
        # if ((COMP_TYPE != 9 && COMP_TYPE != 37 && COMP_TYPE != 42)); then
        #     mode=-d # display-only mode
        # fi

        local IFS=$' \t\n'
        COMPREPLY=($(LC_ALL=C \
            $1 -npq __BASH_MAKE_COMPLETION__=1 \
            ${makef+"${makef[@]}"} "${makef_dir[@]}" .DEFAULT 2>/dev/null |
            _comp_cmd_make__extract_targets "$mode" "$cur"))

        _comp_cmd_make__truncate_non_unique_paths

        if [[ $mode != -d ]]; then
            # Completion will occur if there is only one suggestion
            # so set options for completion based on the first one
            [[ ${COMPREPLY-} == */ ]] && compopt -o nospace
        fi

    fi
} &&
    complete -F _comp_cmd_make make gmake gnumake pmake colormake bmake

# ex: filetype=sh
