# Source `init.tcl' again to restore the `unknown' procedure
# NOTE: DejaGnu has an old `unknown' procedure which unfortunately disables
#       tcl auto-loading.
source [file join [info library] init.tcl]



# Execute a bash command and make sure the exit status is successful.
# If not, output the error message.
# @param string $cmd  Bash command line to execute.  If empty string (""), the
#                     exit status of the previously executed bash command will be
#                     checked; specify `title' to adorn the error message.
# @param string $title  (optional) Command title.  If empty, `cmd' is used.
# @param string $prompt  (optional) Bash prompt.  Default is "/@"
# @param mixed $out  (optional) Reference to (tcl) variable to hold output.
#                    If variable equals -1 (default) the bash command is expected
#                    to return no output.  If variable equals 0, any output
#                    from the bash command is disregarded.
proc assert_bash_exec {{aCmd ""} {title ""} {prompt /@} {out -1}} {
    if {$out != 0 && $out != -1} {upvar $out results}
    if {[string length $aCmd] != 0} {
        send "$aCmd\r"
        expect -ex "$aCmd\r\n"
    }
    if {[string length $title] == 0} {set title $aCmd}
    expect -ex $prompt
    set results $expect_out(buffer);  # Catch output
        # Remove $prompt suffix from output
    set results [
        string range $results 0 [
            expr [string length $results] - [string length $prompt] - 1
        ]
    ]
    if {$out == -1 && [string length $results] > 0} {
        fail "ERROR Unexpected output from bash command \"$title\""
    }

    set cmd "echo $?"
    send "$cmd\r"
    expect {
        -ex "$cmd\r\n0\r\n$prompt" {}
        $prompt {fail "ERROR executing bash command \"$title\""}
    }
}


# Make sure the bash environment hasn't changed between now and the last call
# to `save_env()'.
# @param string $sed  Sed commands to preprocess diff output.
#                     Example calls:
#
#                         # Replace `COMP_PATH=.*' with `COMP_PATH=PATH'
#                         assert_env_unmodified {s/COMP_PATH=.*/COMP_PATH=PATH/}
#
#                         # Remove lines containing `OLDPWD='
#                         assert_env_unmodified {/OLDPWD=/d}
#
# @param string $file  Filename to generate environment save file from.  See
#                      `gen_env_filename()'.
# @param string $diff  Expected diff output (after being processed by $sed)
# @see save_env()
proc assert_env_unmodified {{sed ""} {file ""} {diff ""}} {
    set test "Environment should not be modified"
    _save_env [gen_env_filename $file 2]

        # Prepare sed script

        # Escape special bash characters ("\)
    regsub -all {([\"\\])} $sed {\\\1} sed;  #"# (fix Vim syntax highlighting)
        # Escape newlines
    regsub -all {\n} [string trim $sed] "\r\n" sed

        # Prepare diff script

        # If diff is filled, escape newlines and make sure it ends with a newline
    if {[string length [string trim $diff]]} {
        regsub -all {\n} [string trim $diff] "\r\n" diff
        append diff "\r\n"
    } else {
        set diff ""
    }

        # Execute diff

    # NOTE: The dummy argument 'LAST-ARG' sets bash variable $_ (last argument) to
    #       'LAST-ARG' so that $_ doesn't mess up the diff (as it would if $_
    #       was the (possibly multi-lined) sed script).
    set cmd "diff_env \"[gen_env_filename $file 1]\" \"[gen_env_filename $file 2]\" \"$sed\" LAST-ARG"
    send "$cmd\r"
    expect "LAST-ARG\r\n"

    expect {
        -re "^$diff[wd]@$" { pass "$test" }
        -re [wd]@ {
            fail "$test"

            # Show diff to user

            set diff $expect_out(buffer)
            # Remove possible `\r\n[wd]@' from end of diff
            if {[string last "\r\n[wd]@" $diff] == [string length $diff] - [string length "\r\n[wd]@"]} {
                set diff [string range $diff 0 [expr [string last "\r\n[wd]@" $diff] - 1]]
            }
            send_user $diff;
        }
    }
}


# Sort list.
# `exec sort' is used instead of `lsort' to achieve exactly the
#  same sort order as in bash.
# @param list $items
# @return list  Sort list
proc bash_sort {items} {
    return [split [exec sort << [join $items "\n"]] "\n"]
}


# Get hostnames
# @return list  Hostnames
proc get_hosts {{args {}}} {
    set hosts [exec bash -c "compgen -A hostname"]
    # NOTE: Circumventing var `avahi_hosts' and appending directly to `hosts'
    #       causes an empty element to be inserted in `hosts'.
    #       -- FVu, Fri Jul 17 23:11:46 CEST 2009
    set avahi_hosts [get_hosts_avahi]
    if {[llength $avahi_hosts] > 0} {
        lappend hosts $avahi_hosts
    }
    return $hosts
}


# Get hostnames according to avahi
# @return list  Hostnames
proc get_hosts_avahi {} {
        # Retrieving hosts is successful?
    if { [catch {exec bash -c {
        type avahi-browse >&/dev/null \
            && avahi-browse -cpr _workstation._tcp 2>/dev/null | command grep ^= | cut -d\; -f7 | sort -u
    }} hosts] } {
        # No, retrieving hosts yields error;
            # Reset hosts
        set hosts {}
    }
    return $hosts
}


# Initialize tcl globals with bash variables
proc init_tcl_bash_globals {} {
    global BASH_VERSINFO BASH_VERSION COMP_WORDBREAKS LC_CTYPE
    assert_bash_exec {printf "%s" "$COMP_WORDBREAKS"} {} /@ COMP_WORDBREAKS
    assert_bash_exec {printf "%s " "${BASH_VERSINFO[@]}"} "" /@ BASH_VERSINFO
    set BASH_VERSINFO [eval list $BASH_VERSINFO]
    assert_bash_exec {printf "%s" "$BASH_VERSION"} "" /@ BASH_VERSION
    assert_bash_exec {printf "%s" "$TESTDIR"} "" /@ TESTDIR
    assert_bash_exec {eval $(locale); printf "%s" "$LC_CTYPE"} "" /@ LC_CTYPE
}


# Generate filename to save environment to.
# @param string $file  File-basename to save environment to.  If the file has a
#                      `.exp' suffix, it is removed.  E.g.:
#                      - "file.exp" becomes "file.env1~"
#                      - "" becomes "env.env1~"
#                      - "filename" becomes "filename.env1~"
#                      The file will be stored in the $TESTDIR/tmp directory.
# @param integer $seq  Sequence number.  Must be either 1 or 2.
proc gen_env_filename {{file ""} {seq 1}} {
    if {[string length $file] == 0} {
        set file "env"
    } else {
            # Remove possible directories
        set file [file tail $file]
            # Remove possible '.exp' suffix from filename
        if {[string last ".exp" $file] == [string length $file] - [string length ".exp"]} {
            set file [string range $file 0 [expr [string last ".exp" $file] - 1]]
        }
    }
    return "\$TESTDIR/tmp/$file.env$seq~"
}


# Save the environment for later comparison
# @param string $file  Filename to generate environment save file from.  See
#                      `gen_env_filename()'.
proc save_env {{file ""}} {
    _save_env [gen_env_filename $file 1]
}


# Save the environment for later comparison
# @param string  File to save the environment to.  Default is "$TESTDIR/tmp/env1~".
# @see assert_env_unmodified()
proc _save_env {{file ""}} {
    assert_bash_exec "{ (set -o posix ; set); declare -F; shopt -p; set -o; } > \"$file\""
}


# Source bash_completion package
proc source_bash_completion {} {
    assert_bash_exec {source $(cd "$SRCDIR/.."; pwd)/bash_completion}
}


# Start bash running as test environment.
proc start_bash {} {
    global TESTDIR TOOL_EXECUTABLE spawn_id env srcdirabs
    set TESTDIR [pwd]
    set srcdirabs [file normalize $::srcdir];  # Absolute srcdir
    # If `--tool_exec' option not specified, use "bash"
    if {! [info exists TOOL_EXECUTABLE]} {set TOOL_EXECUTABLE bash}
    set env(SRCDIR) $::srcdir
    set env(SRCDIRABS) $::srcdirabs

    # PS1, INPUTRC, TERM and stty columns must be initialized
    # *before* starting bash to take proper effect.

    # Set fixed prompt `/@'
    set env(PS1) "/@"
    # Configure readline
    set env(INPUTRC) "$::srcdir/config/inputrc"
    # Avoid escape junk at beginning of line from readline,
    # see e.g.  https://bugs.gentoo.org/246091
    set env(TERM) "dumb"
    # Ensure enough columns so expect doesn't have to care about line breaks
    set stty_init "columns 150"

    exp_spawn $TOOL_EXECUTABLE --norc
    assert_bash_exec {} "$TOOL_EXECUTABLE --norc"
    assert_bash_exec "source $::srcdir/config/bashrc"
}


# Redirect xtrace output to a file.
#
# 'set -x' can be very useful for debugging but by default it writes to
# stderr.
#
# This function uses file descriptor 6. This will break if any completion
# tries to use the same descriptor.
proc init_bash_xtrace {{fname xtrace.log}} {
    verbose "Enabling bash xtrace output to '$fname'"
    assert_bash_exec "exec 6>'$fname'"
    assert_bash_exec "BASH_XTRACEFD=6"
    assert_bash_exec "set -o xtrace"
}


# Setup test environment
#
# Common initialization for unit and completion tests.
proc start_interactive_test {} {
    start_bash
    source_bash_completion
    init_tcl_bash_globals

    global OPT_BASH_XTRACE
    if {[info exists OPT_BASH_XTRACE]} {
        init_bash_xtrace
    }
    global OPT_BUFFER_SIZE
    if {![info exists OPT_BUFFER_SIZE]} {
        set OPT_BUFFER_SIZE 20000
    }
    verbose "Changing default expect match buffer size to $OPT_BUFFER_SIZE"
    match_max $OPT_BUFFER_SIZE
    global OPT_TIMEOUT
    if {[info exists OPT_TIMEOUT]} {
        global timeout
        verbose "Changing default expect timeout from $timeout to $OPT_TIMEOUT"
        set timeout $OPT_TIMEOUT
    }
}


# Interrupt completion and sync with prompt.
# Send signals QUIT & INT.
# @param string $prompt  (optional) Bash prompt.  Default is "/@"
proc sync_after_int {{prompt /@}} {
    set test "Sync after INT"
    sleep .1
    send \031\003;  # QUIT/INT
    # Wait to allow bash to become ready
    # See also: https://alioth-lists-archive.debian.net/pipermail/bash-completion-devel/2010-February/002566.html
    sleep .1
    # NOTE: Regexp `.*' causes `expect' to discard previous unknown output.
    #       This is necessary if a completion doesn't match expectations.
    #       For instance with `filetype_xspec' completion (e.g. `kdvi') if
    #       one expects `.txt' as a completion (wrong, because it isn't
    #       there), the unmatched completions need to be cleaned up.
    expect -re ".*$prompt$"
}


# Return current working directory with `TESTDIR' stripped
# @return string  Working directory.  E.g. /, or /fixtures/
proc wd {} {
    global TESTDIR
        # Remove `$TESTDIR' prefix from current working directory
    set wd [string replace [pwd] 0 [expr [string length $TESTDIR] - 1]]/
}
